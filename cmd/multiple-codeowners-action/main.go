package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/alexflint/go-arg"
	"github.com/denormal/go-gitignore"
)

// Constants used in the program.
const (
	CodeownersFileName      = "CODEOWNERS"         // Name of the CODEOWNERS files.
	CodeownersCommentPrefix = "#"                  // Prefix used for comments in CODEOWNERS files.
	DefaultOutputFileName   = ".github/CODEOWNERS" // Default output path for the generated file.
	GeneratedFileWarning    = `
# THIS FILE IS GENERATED, DO NOT EDIT MANUALLY!
# File generated by https://github.com/cbrgm/multiple-codeowners-action
#
# GitHub Codeowners File
#
# https://help.github.com/articles/about-codeowners/
#
# These owners will be the default owners for everything in
# the repo. Unless a later match takes precedence,
# mentioned account names will be requested for
# review when someone opens a pull request.

` // Warning header for the generated file.
)

// args holds the command-line arguments.
var args struct {
	RepoPath string `arg:"--repository,env:REPO_PATH" default:"."`           // Path to the repository root.
	Output   string `arg:"--output,env:OUTPUT" default:".github/CODEOWNERS"` // Path for the output CODEOWNERS file.
	DryRun   bool   `arg:"--dry-run,env:DRY_RUN"`                            // Flag to enable dry run mode.
}

func main() {
	arg.MustParse(&args) // Parse command-line arguments.

	log.Printf("Starting to process CODEOWNERS files in the repository at '%s'.", args.RepoPath)

	rules, err := RewriteCodeownersRules(args.RepoPath)
	if err != nil {
		log.Fatalf("Error processing CODEOWNERS files: %v", err)
	}

	if len(rules) == 0 {
		log.Println("No CODEOWNERS rules found or generated.")
		return
	}
	log.Printf("Successfully processed CODEOWNERS files. %d rules found.", len(rules))

	output := GenerateCodeownersFile(rules)

	if args.DryRun {
		log.Println("Dry run mode enabled. The combined CODEOWNERS file will not be written. Output:")
		fmt.Println("\n" + output) // Print the generated output to stdout in dry run mode.
	} else {
		log.Printf("Generating combined CODEOWNERS file at '%s'.", args.Output)
		if err := os.WriteFile(args.Output, []byte(output), 0o644); err != nil {
			log.Fatalf("Error writing to output file '%s': %v", args.Output, err)
		}
		log.Printf("CODEOWNERS file successfully generated at '%s'.", args.Output)
	}
}

// RewriteCodeownersRules reads and processes CODEOWNERS files from the given repository path.
// It returns a slice of combined and rewritten CODEOWNERS rules.
func RewriteCodeownersRules(path string) ([]string, error) {
	root, err := validateRoot(path)
	if err != nil {
		return nil, err
	}

	var rewrittenRules []string
	err = WalkCodeownersFiles(root, func(coPath string) error {
		rules, procErr := ProcessCodeownersFile(root, coPath)
		rewrittenRules = append(rewrittenRules, rules...)
		return procErr
	})

	return rewrittenRules, err
}

// validateRoot validates the provided path and ensures it's a directory.
// It returns the absolute path if valid, otherwise an error.
func validateRoot(path string) (string, error) {
	absPath, err := filepath.Abs(path)
	if err != nil {
		return "", fmt.Errorf("error resolving path %s: %w", path, err)
	}

	info, err := os.Stat(absPath)
	if err != nil {
		return "", fmt.Errorf("error reading path %s: %w", absPath, err)
	}

	if !info.IsDir() {
		return "", fmt.Errorf("path %s is not a directory", absPath)
	}

	return absPath, nil
}

// WalkCodeownersFiles walks through the files in a directory and its subdirectories,
// applying the provided processing function to each CODEOWNERS file found.
func WalkCodeownersFiles(root string, procFn func(coPath string) error) error {
	ignore := initGitignore(root)
	dirQueue := NewQueue[string]()
	dirQueue.Enqueue(root)

	for dirQueue.Len() > 0 {
		currentDir := dirQueue.Dequeue()
		if shouldIgnoreDir(ignore, currentDir) {
			continue
		}

		dirEntries, err := os.ReadDir(currentDir)
		if err != nil {
			return fmt.Errorf("error reading dir %s: %w", currentDir, err)
		}

		sortDirEntries(dirEntries)
		for _, entry := range dirEntries {
			if err := handleDirEntry(entry, currentDir, ignore, dirQueue, procFn); err != nil {
				return err
			}
		}
	}

	return nil
}

// initGitignore initializes a gitignore parser for the given root directory.
func initGitignore(root string) gitignore.GitIgnore {
	ignore, _ := gitignore.NewRepository(root)
	return ignore
}

// shouldIgnoreDir checks if the given directory should be ignored based on .gitignore rules.
func shouldIgnoreDir(ignore gitignore.GitIgnore, path string) bool {
	if filepath.Base(path) == ".git" {
		return true // Always ignore .git directory
	}

	if ignore == nil || ignore.Base() == path {
		return false // Do not ignore if there's no .gitignore or it's the root path
	}

	match := ignore.Match(path)
	return match != nil && match.Ignore()
}

// sortDirEntries sorts directory entries by name.
func sortDirEntries(dirEntries []fs.DirEntry) {
	sort.Slice(dirEntries, func(i, j int) bool { return dirEntries[i].Name() < dirEntries[j].Name() })
}

// handleDirEntry processes a directory entry, either enqueuing it for further processing
// if it's a directory, or processing it with procFn if it's a CODEOWNERS file.
func handleDirEntry(entry fs.DirEntry, currentDir string, ignore gitignore.GitIgnore, dirQueue *Queue[string], procFn func(coPath string) error) error {
	if isCodeownersFile(entry) {
		path := filepath.Join(currentDir, entry.Name())
		if strings.HasSuffix(path, args.Output) {
			return nil // Skip the output file to avoid self-processing
		}
		return procFn(path)
	} else if entry.IsDir() && !shouldIgnoreDir(ignore, filepath.Join(currentDir, entry.Name())) {
		dirQueue.Enqueue(filepath.Join(currentDir, entry.Name())) // Enqueue directory for further processing
	}
	return nil
}

func isCodeownersFile(entry fs.DirEntry) bool {
	return !entry.IsDir() && entry.Name() == CodeownersFileName
}

// ProcessCodeownersFile processes a single CODEOWNERS file, rewriting its rules based on the repository root.
func ProcessCodeownersFile(root, path string) ([]string, error) {
	lines, err := readCodeownersFile(path)
	if err != nil {
		return nil, err
	}

	rewrittenPath, err := rewriteCodeownersPath(root, path)
	if err != nil {
		return nil, err
	}

	return rewriteCodeownersRules(rewrittenPath, lines), nil
}

// readCodeownersFile reads the contents of a CODEOWNERS file and returns its lines.
func readCodeownersFile(path string) ([]string, error) {
	bytes, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("error reading CODEOWNERS file %s: %w", path, err)
	}
	return strings.Split(string(bytes), "\n"), nil
}

// rewriteCodeownersPath calculates the path relative to the repository root for use in the generated CODEOWNERS file.
func rewriteCodeownersPath(root, path string) (string, error) {
	dir := filepath.Dir(path)
	if dir == root {
		return "", nil // Root-level CODEOWNERS file
	}
	relDir, err := filepath.Rel(root, dir)
	if err != nil {
		return "", fmt.Errorf("can't rewrite CODEOWNERS path %s: %s", path, err)
	}
	return fmt.Sprintf("/%s", relDir), nil
}

// rewriteCodeownersRules rewrites the rules from a CODEOWNERS file for inclusion in the generated file.
func rewriteCodeownersRules(rewrittenPath string, lines []string) []string {
	var rewrittenRules []string
	for _, line := range lines {
		if isCodeownersRule(line) {
			rewritten := RewriteCodeownersRule(rewrittenPath, line)
			rewrittenRules = append(rewrittenRules, rewritten)
		}
	}
	return rewrittenRules
}

// isCodeownersRule checks if a line from a CODEOWNERS file represents an ownership rule.
func isCodeownersRule(line string) bool {
	return strings.TrimSpace(line) != "" && !strings.HasPrefix(line, CodeownersCommentPrefix)
}

// RewriteCodeownersRule rewrites a single CODEOWNERS rule based on the new path context.
func RewriteCodeownersRule(rewrittenPath, rule string) string {
	if isDirRule(rule) {
		return rewriteDirRule(rewrittenPath, rule)
	}
	return rewriteNonDirRule(rewrittenPath, rule)
}

// isDirRule checks if a CODEOWNERS rule applies to a directory.
func isDirRule(rule string) bool {
	return strings.Contains(strings.SplitN(rule, " ", 2)[0], "@")
}

// rewriteDirRule rewrites a directory-level CODEOWNERS rule.
func rewriteDirRule(path, rule string) string {
	if path == "/." {
		path = "*"
	}
	return fmt.Sprintf("%s %s", path, rule)
}

// rewriteNonDirRule rewrites a file or pattern-level CODEOWNERS rule.
func rewriteNonDirRule(path, rule string) string {
	tokens := strings.SplitN(rule, " ", 2)
	if len(tokens) < 2 {
		return ""
	}
	ruleTarget := filepath.Join(path, strings.TrimSpace(tokens[0]))
	return fmt.Sprintf("%s %s", ruleTarget, strings.TrimSpace(tokens[1]))
}

// GenerateCodeownersFile generates the final content for the combined CODEOWNERS file.
func GenerateCodeownersFile(rules []string) string {
	return fmt.Sprintf("%s\n\n%s\n", GeneratedFileWarning, strings.Join(rules, "\n"))
}

// Queue is a generic FIFO (first in, first out) queue.
type Queue[T any] struct {
	items []T // items holds the elements of the queue.
}

// NewQueue creates and returns a new Queue.
func NewQueue[T any]() *Queue[T] {
	return &Queue[T]{items: make([]T, 0)}
}

// Enqueue adds an item to the end of the queue.
func (q *Queue[T]) Enqueue(item T) {
	q.items = append(q.items, item)
}

// Dequeue removes and returns the first item from the queue.
func (q *Queue[T]) Dequeue() T {
	if len(q.items) == 0 {
		var zero T // zero value of type T
		return zero
	}
	item := q.items[0]
	q.items = q.items[1:]
	return item
}

// Len returns the number of items in the queue.
func (q *Queue[T]) Len() int {
	return len(q.items)
}
